jps：查看java进程状态信息； 
jstack：查看线程堆栈情况，可检查死锁；
jmap：查看堆内存使用情况；
jstat：查看堆使用和回收情况；
线程调用start()方式之后，线程处于Runnable状态，获取cpu执行时间才处于runnning状态；
在Daemon线程中产生的新线程也是Daemon的；
synchronized是可重入的非公平锁，系统自动解锁；
处于Contention List、Entry List、Wait List里面的线程都处于阻塞状态，阻塞操作是由操作系统完成的；
synchronized非公平体现：1）线程在进入Contention List之前会先尝试自旋获取锁，获取失败才进入Contention List、2）成为OnDeck线程的随机性；
synchronized加锁就是在竞争对象监视器，重量级操作（需要在用户态和系统态之间切换，依赖于操作系统 Mutex Lock），需要调用系统相关接口；
AtomicReference<V>：将一个对象的所有操作转化成原子操作；
AtomicStampedReference<V>：可以解决ABA问题；
锁的状态总共有四种：无锁状态、
					偏向锁（偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护，只有一个线程竞争锁的时候用到）、
					轻量级锁（依赖CAS）、
					重量级锁；
wait() -> 线程进入WAITING状态、sleep() -> 线程进入TIMED_WAITING状态；
ArrayBlockingQueue区分公平性和非公平性，具体体现在ReentrantLock成本变量身上；
CyclicBarrier一般用于一组线程互相等待至某个状态；
底层实现不一样，synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略；
让出CPU：a）yield、b）IO阻塞；c）线程执行结束；
动态语言，是指程序在运行时可以改变其结构；
java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法。并且对于任意一个对象，都能够调用它的任意一个方法；
java反射简单来说：运行时状态下动态获取类信息，动态调用对象方法；
Java程序中许多对象在运行时都会出现两种类型：编译时类型和运行时类型：编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定；
可以通过反射来获取注解；
泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型，泛型的本质是参数化类型；
泛型擦除实现：首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界，把代码中的类型参数都替换 成具体的类；
序列化用字节数组来保存，序列化保存的是状态，所以静态变量不会被序列化；
序列化ID决定着是否可以反序列化成功（ObjectInputStream）：比较字节流中的序列化ID是否和本地实体类中的序列化ID一致；
交换机--数据链路层--数据帧--MAC地址；路由--网络层（IP协议）--数据包--IP地址；
传输层：定义传输数据的协议（TCP、UDP）和端口号--报文段；会话层：建立数据传输通道；表示层：解密、加密，压缩、解压；应用层：FTP、HTTP；
HTTPS默认端口：443；
数据库一个page占64KB；
MyISAM：适用于只读场景，读取速度更快；
索引列不能参与计算，否则索引会失效；
数据库第二范式理解：表需要有主键，并且其他表字段需要依赖于这个主键；
数据库第三范式理解：每列都和主键直接相关，而不是间接相关；
存储过程：一组SQL集，第一次调用编译，编译结果存放在缓存中，后面不需要再编译；
数据库并发策略：乐观锁、悲观锁、时间戳；
表级锁：共享读锁，写独占锁；
页级锁：介于行级锁（太慢）和表级锁（冲突多）之间，锁住相邻的一组记录；
Redis分布式锁：set key value（随机UUID，可识别锁），并expire设置一个超时时间自动释放锁，手动释放锁delete；
垂直切分：数据库表（访问频率一致的一起、经常一起访问的一起）部署到不同数据库上；
水平切分：数据量太大时，将数据记录按照一定规则（比如散列）分配到相同结构不同表、甚至不同库上；
红黑树：一种特殊的二叉查找树，节点区分红黑两种节点；


IO、NIO、poll、epoll不熟；
java对synchronized优化；
	java1.6：有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等；
	java1.7和1.8：关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁；
特殊的阻塞队列；
volatile底层实现；
java注解；
Spring原理；
微服务；
Netty与RPC；
ZooKeeper；
Kafka；
RabbitMQ；
HBase；
MongoDB；
Cassandra；
设计模式；
负载均衡；
基于Redis分布式锁；
两段提交协议；
三阶段提交协议；
柔性事务；
CAP；
一致性算法；
回溯算法；最短路径算法；最大子数组算法；最长公共子序算法；最小生成树算法；
红黑树；
位图；
缓存降级；
Hadhoop；
Spark；
Storm；
YARN；
机器学习；
云计算；