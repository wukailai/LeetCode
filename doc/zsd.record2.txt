查看linux平均负载：uptime；
top命令：查看cpu和内存占有率；
mysql什么时候加锁：insert、delete、update语句自动加拍他锁，select语句默认不加锁，但是可以显示加锁：
select * from table lock in share mode；
mysql事务隔离是通过锁来实现的：
a）读未提交：不加锁；
b）读已提交：每次执行语句时创建一次快照；
c）可重复读：仅在事务开始时创建一次快照；
d）串行化：单线程执行，读加共享锁，写加排他锁；
FutureTask：finally做的工作：runner置为null；如果被中断，处理中断（处理方式：调用Thread.yield()让出CPU执行时间）；
FutureTask：set()、setException()、cancel(true/false)执行完后都会执行finishCompletion()，该方法是唤醒所有等待在waiters(WaitNode)
上面的线程，注意：节点是首节点插入，但是唤醒是从首节点开始的，所以唤醒满足后进先唤醒原则；
cancel(true/false)：只要状态不为NEW或者CAS NEW状态失败，就返回false；
解决数据库跨库查询方法：1）聚合服务封装查询；2）多数据源查询（就是一个微服务配置多个数据源）；3）My Cat；4）数据库中间件Sharding-Shpere；
hash算法好坏评判标准：
    1）平衡性（缓存分配到所有机器上，虚拟节点解决平衡性问题）；
    2）单调性（如果有新机器加入集群，已分配的缓存应该保持原样或者重新分配到新机器上）；
    3）分散性；
    4）负载；
一致性hash算法：0-2^32-1环形空间；
NIO也阻塞，只不过相比较于BIO，NIO是select方法阻塞，BIO则是read、write阻塞；
epoll：
    a）epoll_create（创建epoll对象）；
    b）epoll_ctl（socket添加epoll对象红黑树，注册回调函数，回调函数用于将就绪事件添加到双向链表）；
    c）epoll_wait（就绪事件的连接添加到双向链表里面）；
epoll两种模式：LT（事件没处理完，重复进双向链表）；ET（只进一次双向链表）；