分库分表中，数据库主键使用分布式的高并发唯一id生成器来生成；
mysql优化方式之一：使用先使用范围查询定位id（或者索引），然后再使用索引进行定位数据，能够提高好几倍查询速度。即先 select id，然后再 select *；
服务器优化方向：
    a）增加负载均衡服务器（让扩容也变得简单起来）；
    b）缓存静态文件（不常变化的文件，如图片、html文件）；
    c）缓存放在距离用户更近、性能更好的服务器（性能兼顾速度和运行负载）；
    d）压缩数据；
    e）实时监控及时发现问题；
锁优化：
    a）减少锁执行时间；
    b）减少锁的粒度；
    c）锁分离；
    d）锁降级；
    e）锁粗化：减少加锁、释放锁次数；
    f）所消除；
常见的消息模式：
    a）消息队列模式；
        i）实现生产者与消费者之间的解耦；
        ii）一个消息只能被一个消费者消费；
        iii）消费者如果处理消息失败，消息系统一般会把这个消息放回队列，这样其他消费者可以继续处理；
    b）发布/订阅模式；
        i）单个消息可以被多个订阅者并发获取和处理；实现逻辑：消息被生产后，复制到多个队列中；
        ii）RabbitMQ中的主题（Object）就是发布/订阅模式的一种具体实现；
        iii）订阅分为两种：临时订阅和持久订阅；
        vi）RabbitMQ使用交换器来实现发布/订阅模式；
RabbitMQ实现原理：
    1）发布者直接把消息发布到交换器上而不需要知道消息有哪些订阅者；
    2）每一个订阅了交换器的消费者都会创建一个队列，交换器会把消息放入队列以供消费者消费；
    3）消息交换器也可以基于各种路由规则为一些订阅者过滤消息；
    4）RabbitMQ的消费者可以以组队的方式（消费者组）竞争处理队列上的消息；
    5）RabbitMQ内置重试逻辑和死信（dead-letter）交换器；
    6）对于发送到队列或者交换器上的消息，RabbitMQ不保证它们的顺序，消息放回也会打乱顺序，多个消费者消费一个队列也会造成顺序错乱；
    7）可以设置消息存活时间（TTL），预期时间内消息没有被消费，消息会从队列中被移除；
    8）支持延迟或者预定消息；
Kafka：
    1）Kafka是一种分布式流式系统；
    2）Kafka的存储层是使用分区事务日志来实现的；
    3）Kafka按照类别存储记录集，并且把这种类别称为主题，Kafka为每个主题维护一个消息分区日志，
    每个分区都是由有序的不可变的记录序列组成，并且消息都是连续的被追加在尾部；
    4）Kafka使用轮询分区器（partitioner）把消息一致的分配到多个分区上
    5）消费者通过维护分区的偏移（或者说索引）来顺序的读出消息，然后消费消息；
    6）单个消费者可以消费多个不同的主题；
    7）消费同一个主题的多个消费者构成的组称为消费者组；
    8）消费者维护自己的分区偏移，持久订阅在重启之后不会丢失偏移；
    9）Kafka能够保证发送到相同主题分区的所有消息都能够按照顺序处理；
    10）Kafka在处理消息之前是不允许消费者过滤一个主题中的消息；
    11）Kafka设计之初就是保存消息的；
优先选择RabbitMQ的条件：
    1）高级灵活的路由规则；
    2）消息时序控制（控制消息过期或者消息延迟）；
    3）高级的容错处理能力，在消费者更有可能处理消息不成功的情景中（瞬时或者持久）；
    4）更简单的消费者实现；
优先选择Kafka的条件：
    1）严格的消息顺序；
    2）延长消息留存时间，包括过去消息重放的可能；
    3）传统解决方案无法满足的高伸缩能力；
正向代理代理客户端（VPN），反向代理代理服务器（负载均衡）；
TCC（Try-Confirm-Cancel）分布式事务：设置中间状态 + ConfirmService（确认） + CancelService（回滚），Confirm、Cancel一直不成功会一直重试；
TTC事务活动日志（存数据库或者磁盘文件）会记录事务运行阶段和状态；
mysql自增ID用完，会停止自增，所以会报主键冲突错误；
mysql事务原理：事务开启之后，所有的操作都会临时保存到事务日志中，事务日志只有在得到commit命令才会同步到数据表中，
其他任何情况都会清空事务日志(rollback、断开连接两种情况)；
Myisam：批量插入速度比INNODB要快；
sql小技巧：
    a）避免使用select *，如果非得使用select *，可以先进行索引定位；
    b）between代替in；
    c）join好于where，因为不需要创建临时表；
    d）group单独使用会排序（影响性能），在group by后面增加order by null就可以防止排序；
mysql使用主从服务器来实现读写分离，主服务器负责写，从服务器负责读；
java +连接符是通过StringBuilder的append + toString6在堆里重新创建一个对象实现的；